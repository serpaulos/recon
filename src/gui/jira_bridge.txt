from __future__ import annotations

from pathlib import Path
from typing import List, Set, Tuple, Optional

import pandas as pd

# secrets/env
from src.config.secrets import (
    JIRA_BASE_URL, JIRA_USERNAME, JIRA_PASSWORD, JIRA_VERIFY_SSL,
    JIRA_PROJECT_KEY, JIRA_ISSUE_TYPE, JIRA_TEMPLATE_ISSUE,
)

from src.config.app_config import ENVS

# IMPORTA workflow â€œprodâ€
from src.jira.jira_client import JiraClient, JiraHttpConfig
from src.jira.jira_config import JiraConfig, get_assignment_group_name
from src.jira.jira_service import attach_files
from src.jira.jira_workflow import create_recon_event_and_attach

USER_HOME = Path.home()

# Ex: legado: [("ACCTERR","X201767A"), ...]
LegacyJobs = List[Tuple[str, str]]

SEND_BASE_DIR = (
        USER_HOME
        / "Euronext"
        / "ES Operations - General"
        / "16. Files"
        / "CPH_Reconciliation"
)


def build_jira_client() -> JiraClient:
    http_cfg = JiraHttpConfig(
        base_url=JIRA_BASE_URL,
        username=JIRA_USERNAME,
        password=JIRA_PASSWORD,
        verify_ssl=JIRA_VERIFY_SSL,
        timeout=(10, 60),  # connect, read
    )
    return JiraClient(http_cfg)


def build_jira_workflow_cfg() -> JiraConfig:
    return JiraConfig(
        base_url=JIRA_BASE_URL,
        username=JIRA_USERNAME,
        password=JIRA_PASSWORD,
        verify_ssl=JIRA_VERIFY_SSL,
        project_key=JIRA_PROJECT_KEY,
        issue_type_name=JIRA_ISSUE_TYPE,
        template_issue_key=JIRA_TEMPLATE_ISSUE,
    )


def try_create_jira(
        *,
        env: str,
        df_last4: pd.DataFrame,
        operating_date_ddmmyyyy: str,
        files: List[Path],
) -> Optional[str]:
    jira = build_jira_client()
    cfg = build_jira_workflow_cfg()

    # sÃ³ garante que o nome do grupo existe (QA/PROD)
    _ = get_assignment_group_name()

    return create_recon_event_and_attach(
        jira,
        cfg,
        env=env,
        df_last4=df_last4,
        operating_date_ddmmyyyy=operating_date_ddmmyyyy,
        files=files,
        labels=["CPH_Reconciliation"],
    )


def collect_jira_attachments(
        env: str,
        legacy_jobs: dict[str, LegacyJobs],
        *,
        log=None,  # funÃ§Ã£o opcional de log (ctx.log)
) -> List[Path]:
    """
    Retorna os CSVs encontrados para anexar no Jira.
    Loga quantos arquivos foram encontrados e quais faltaram.
    """
    send_dir = SEND_BASE_DIR / ENVS[env]["folder"] / "Send"

    if not send_dir.exists():
        raise FileNotFoundError(
            f"Send dir not found (likely not synced yet):\n{send_dir}\n"
            "Run BAT first (it triggers the sync)."
        )

    found_files: List[Path] = []
    missing: List[str] = []

    for job_name, job_id in legacy_jobs.get(env, []):
        base = f"{job_name}_{job_id}"

        candidates = [
            send_dir / f"{base}.CSV",
            send_dir / f"{base}.csv",
            send_dir / base,
        ]

        file = next((p for p in candidates if p.exists() and p.is_file()), None)

        if file:
            found_files.append(file)
        else:
            missing.append(base)

    # ---- logging amigÃ¡vel ----
    if log:
        log(f"ðŸ“Ž Jira attachments: found {len(found_files)}/{len(legacy_jobs.get(env, []))} files")
        if missing:
            log(f"âš ï¸ Missing attachments: {', '.join(missing)}")

    return found_files


def _make_jira_client() -> JiraClient:
    http_cfg = JiraHttpConfig(
        base_url=JIRA_BASE_URL,
        username=JIRA_USERNAME,
        password=JIRA_PASSWORD,
        verify_ssl=JIRA_VERIFY_SSL,
        timeout=60,
    )
    return JiraClient(http_cfg)


def try_attach_only(*, issue_key: str, files: List[Path]) -> List[str]:
    jira = _make_jira_client()
    return attach_files(jira, issue_key, files)


def attach_files_to_issue(*, issue_key: str, files: List[Path]) -> List[str]:
    jira = build_jira_client()
    return attach_files(jira, issue_key, files)


def list_attachment_names(issue_key: str) -> Set[str]:
    """
    Retorna o conjunto de nomes de anexos jÃ¡ presentes no issue.
    """
    jira = _make_jira_client()
    r = jira.get(f"/rest/api/2/issue/{issue_key}", params={"fields": "attachment"})
    if r.status_code != 200:
        raise RuntimeError(f"Failed to read attachments: {r.status_code} {r.text[:300]}")

    atts = (r.json().get("fields", {}) or {}).get("attachment", []) or []
    return {a.get("filename") for a in atts if a.get("filename")}


def filter_new_files(issue_key: str, files: List[Path], *, log=None) -> List[Path]:
    """
    Remove da lista os arquivos cujo nome jÃ¡ existe no Jira.
    """
    existing = list_attachment_names(issue_key)

    new_files = [p for p in files if p.name not in existing]

    if log:
        log(f"ðŸ“Ž Jira already has {len(existing)} attachment(s).")
        skipped = [p.name for p in files if p.name in existing]
        if skipped:
            log(f"â­ï¸ Skipping already-uploaded: {', '.join(skipped)}")
        log(f"â¬†ï¸ Will upload {len(new_files)}/{len(files)} new file(s).")

    return new_files


def attach_files_to_issue(issue_key: str, files: List[Path], *, skip_existing: bool = True, log=None) -> List[str]:
    """
    Anexa arquivos ao issue. Se skip_existing=True, nÃ£o reenvia nomes jÃ¡ existentes.
    """
    to_upload = files
    if skip_existing:
        to_upload = filter_new_files(issue_key, files, log=log)

    if not to_upload:
        return []

    jira = _make_jira_client()
    return attach_files(jira, issue_key, to_upload)
